import { FirebaseApp } from 'firebase/app';
import * as vue_demi from 'vue-demi';
import { Ref, ShallowRef, App } from 'vue-demi';
import * as firebase_database from 'firebase/database';
import { DataSnapshot, DatabaseReference, Query as Query$1 } from 'firebase/database';
import * as firebase_firestore from 'firebase/firestore';
import { DocumentReference, CollectionReference, Query, SnapshotOptions, SnapshotListenOptions, FirestoreDataConverter, DocumentData, FirestoreError } from 'firebase/firestore';
import * as firebase_auth from 'firebase/auth';
import { User } from 'firebase/auth';
import { AppCheckOptions } from 'firebase/app-check';
import * as firebase_storage from 'firebase/storage';
import { StorageReference, FullMetadata, SettableMetadata, UploadTaskSnapshot, UploadTask, StorageError, UploadMetadata } from 'firebase/storage';

/**
 * Allow resetting a subscription vue ref when the source changes or is removed. `false` keeps the value as is while
 * true resets it to `null` for objects and `[]` for arrays. A function allows to specify a custom reset value.
 */
type ResetOption = boolean | (() => unknown);
/**
 * @internal
 */
type _Nullable<T> = T | null | undefined;
type _FirestoreDataSource = DocumentReference<unknown> | CollectionReference<unknown> | Query<unknown>;
/**
 * @internal
 */
interface _RefWithState<T, E = Error> extends Ref<T> {
    /**
     * Realtime data wrapped in a Vue `ref`
     */
    get data(): Ref<T>;
    /**
     * Reactive Error if the firebase operation fails
     */
    get error(): Ref<E | undefined>;
    /**
     * Reactive loading state
     */
    get pending(): Ref<boolean>;
    /**
     * Reactive promise that resolves when the data is loaded or rejects if there is an error
     */
    get promise(): ShallowRef<Promise<T>>;
    /**
     * Stops listening to the data changes and stops the Vue watcher.
     */
    stop: (reset?: ResetOption) => void;
}
/**
 * @internal
 */
type _MaybeRef<T> = T | Ref<T>;
/**
 * Base options for the data source options in both Firestore and Realtime Database.
 *
 * @internal
 */
interface _DataSourceOptions {
    /**
     * Use the `target` ref instead of creating one.
     */
    target?: Ref<unknown>;
    /**
     * Optional key to handle SSR hydration. **Necessary for Queries** or when the same source is used in multiple places
     * with different converters.
     */
    ssrKey?: string;
    /**
     * If true, the data will be reset when the data source is unbound. Pass a function to specify a custom reset value.
     */
    reset?: ResetOption;
    /**
     * If true, wait until the data is loaded before setting the data for the first time. For Firestore, this includes
     * nested refs. This is only useful for lists and collections. Objects and documents do not need this.
     */
    wait?: boolean;
    /**
     * Should the data be fetched once rather than subscribing to changes.
     * @experimental Still under development
     */
    once?: boolean;
}

interface DatabaseSnapshotSerializer<T = unknown> {
    (snapshot: DataSnapshot): NonNullable<VueDatabaseDocumentData<T>>;
}
interface _RefDatabase<T> extends _RefWithState<T, Error> {
}
/**
 * Type used by default by the `serialize` option.
 */
type VueDatabaseDocumentData<T = unknown> = null | (T & {
    /**
     * id of the document
     */
    readonly id: string;
});
/**
 * Same as VueDatabaseDocumentData but for a query.
 */
type VueDatabaseQueryData<T = unknown> = Array<NonNullable<VueDatabaseDocumentData<T>>>;

/**
 * Global option type when binding one database reference
 * @internal
 */
interface _DatabaseRefOptions extends _DataSourceOptions {
    /**
     * Function to transform snapshots into data. Make sure to reuse the original serializer to add the object id. See
     * https://vuefire.vuejs.org/guide/global-options.html
     */
    serialize?: DatabaseSnapshotSerializer;
}
/**
 * Global defaults type override options for all database bindings.
 * @internal
 */
interface _DatabaseRefOptionsWithDefaults extends _DatabaseRefOptions {
    /**
     * @defaultValue `false`
     */
    reset: ResetOption;
    /**
     * @defaultValue `true`
     */
    wait: boolean;
    serialize: DatabaseSnapshotSerializer;
}
declare const DEFAULT_OPTIONS$1: _DatabaseRefOptionsWithDefaults;

/**
 * Options for the Firebase Database Plugin that enables the Options API such as `$databaseBind` and `$databaseUnbind`.
 */
interface DatabasePluginOptions extends _DatabaseRefOptions {
    /**
     * @deprecated: was largely unused and not very useful. Please open an issue with use cases if you need this.
     */
    bindName?: string;
    /**
     * @deprecated: was largely unused and not very useful. Please open an issue with use cases if you need this.
     */
    unbindName?: string;
}
type VueFirebaseObject = Record<string, Query$1 | DatabaseReference>;
type FirebaseOption = VueFirebaseObject | (() => VueFirebaseObject);
/**
 * Install this plugin if you want to add `$databaseBind` and `$databaseUnbind` functions. Note this plugin is only necessary if
 * you use the Options API. If you **exclusively use the Composition API** (e.g. `useObject()` and `useList()`), you
 * should not add it.
 *
 * @deprecated Use `VueFire` and `VueFireDatabaseOptionsAPI` with the `modules` option instead.
 *
 * @param app
 * @param pluginOptions
 */
declare function databasePlugin(app: App, pluginOptions?: DatabasePluginOptions, firebaseApp?: FirebaseApp): void;
/**
 * VueFire Database Module to be added to the `VueFire` Vue plugin options. If you **exclusively use the Composition
 * API** (e.g. `useObject()` and `useList()`), you should not add it.
 *
 * @example
 *
 * ```ts
 * import { createApp } from 'vue'
 * import { VueFire, VueFireDatabaseOptionsAPI } from 'vuefire'
 *
 * const app = createApp(App)
 * app.use(VueFire, {
 *   modules: [VueFireDatabaseOptionsAPI()],
 * })
 * ```
 */
declare function VueFireDatabaseOptionsAPI(pluginOptions?: DatabasePluginOptions): (firebaseApp: FirebaseApp, app: App) => void;
declare module '@vue/runtime-core' {
    interface ComponentCustomProperties {
        /**
         * Binds a reference
         *
         * @param name
         * @param reference
         * @param options
         */
        $databaseBind(name: string, reference: DatabaseReference | Query$1, options?: _DatabaseRefOptions): Promise<DataSnapshot>;
        /**
         * {@inheritDoc ComponentCustomProperties.$databaseBind}
         * @deprecated Use `$databaseBind` instead.
         */
        $rtdbBind(name: string, reference: DatabaseReference | Query$1, options?: _DatabaseRefOptions): Promise<DataSnapshot>;
        /**
         * Unbinds a bound reference
         */
        $databaseUnbind: (name: string, reset?: ResetOption) => void;
        /**
         * {@inheritDoc ComponentCustomProperties.$databaseUnbind}
         * @deprecated Use `$databaseUnbind` instead.
         */
        $rtdbUnbind: (name: string, reset?: ResetOption) => void;
        /**
         * Bound database references
         */
        $firebaseRefs: Readonly<Record<string, DatabaseReference>>;
    }
    interface ComponentCustomOptions {
        /**
         * Calls `$databaseBind` at created
         */
        firebase?: FirebaseOption;
    }
}

interface UseDatabaseRefOptions extends _DatabaseRefOptions {
}
type UseListOptions = UseDatabaseRefOptions;
type UseObjectOptions = UseDatabaseRefOptions;
/**
 * Creates a reactive variable connected to the database.
 *
 * @param reference - Reference or query to the database
 * @param options - optional options
 */
declare function useList<T = unknown>(reference: _MaybeRef<DatabaseReference | Query$1>, options?: UseListOptions): _RefDatabase<VueDatabaseQueryData<T>>;
declare function useObject<T = unknown>(reference: _MaybeRef<DatabaseReference>, options?: UseObjectOptions): _RefDatabase<VueDatabaseDocumentData<T> | undefined>;
/**
 * Retrieves the Database instance.
 *
 * @param name - name of the application
 * @returns the Database instance
 */
declare function useDatabase(name?: string): firebase_database.Database;

/**
 * Options when binding a Firestore document or collection.
 */
interface FirestoreRefOptions extends _DataSourceOptions {
    /**
     * The maximum depth to bind nested refs. A nested ref that isn't bound will stay as the ref path while a bound ref
     * will contain the same data as if the ref was bound directly.
     */
    maxRefDepth?: number;
    /**
     * @inheritDoc {SnapshotOptions}
     */
    snapshotOptions?: SnapshotOptions;
    /**
     * @inheritDoc {SnapshotListenOptions}
     */
    snapshotListenOptions?: SnapshotListenOptions;
    /**
     * Default Firestore converter to use with snapshots.
     */
    converter?: FirestoreDataConverter<unknown>;
}
/**
 * Type of the global options for firestore refs. Some values cannot be `undefined`.
 * @internal
 */
interface _FirestoreRefOptionsWithDefaults extends FirestoreRefOptions {
    /**
     * @defaultValue `false`
     */
    reset: ResetOption;
    /**
     * @defaultValue `true`
     */
    wait: boolean;
    /**
     * @defaultValue `2`
     */
    maxRefDepth: number;
    /**
     * Default Firestore converter to use with snapshots. Make sure to reuse the original serializer to add the object id.
     * See https://vuefire.vuejs.org/guide/global-options.html
     */
    converter: FirestoreDataConverter<unknown>;
}
/**
 * Global default options
 */
declare const DEFAULT_OPTIONS: _FirestoreRefOptionsWithDefaults;

interface _UseFirestoreRefOptions extends FirestoreRefOptions {
    /**
     * @deprecated: use `.withConverter()` instead
     */
    converter?: any;
}
interface UseCollectionOptions extends _UseFirestoreRefOptions {
}
/**
 * Creates a reactive collection (usually an array) of documents from a collection ref or a query from Firestore. Extracts the the type of the
 * query or converter.
 *
 * @param collectionRef - query or collection
 * @param options - optional options
 */
declare function useCollection<R extends CollectionReference<unknown> | Query<unknown>>(collectionRef: _MaybeRef<_Nullable<R>>, options?: UseCollectionOptions): _RefFirestore<_InferReferenceType<R>[]>;
/**
 * Creates a reactive collection (usually an array) of documents from a collection ref or a query from Firestore.
 * Accepts a generic to **enforce the type** of the returned Ref. Note you can (and probably should) use
 * `.withConverter()` to have stricter type safe version of a collection reference.
 *
 * @param collectionRef - query or collection
 * @param options - optional options
 */
declare function useCollection<T>(collectionRef: _MaybeRef<_Nullable<CollectionReference | Query>>, options?: UseCollectionOptions): _RefFirestore<VueFirestoreQueryData<T>>;
interface UseDocumentOptions extends _UseFirestoreRefOptions {
}
/**
 * Creates a reactive document from a document ref from Firestore. Extracts the the type of the converter
 *
 * @param documentRef - document reference
 * @param options - optional options
 */
declare function useDocument<R extends DocumentReference<unknown>>(documentRef: _MaybeRef<_Nullable<R>>, options?: UseDocumentOptions): _RefFirestore<_InferReferenceType<R>>;
/**
 * Creates a reactive collection (usually an array) of documents from a collection ref or a query from Firestore.
 * Accepts a generic to **enforce the type** of the returned Ref. Note you can (and probably should) use
 * `.withConverter()` to have stricter type safe version of a collection reference.
 *
 * @param collectionRef - query or collection
 * @param options - optional options
 */
declare function useDocument<T>(documentRef: _MaybeRef<_Nullable<DocumentReference>>, options?: UseDocumentOptions): _RefFirestore<VueFirestoreDocumentData<T>>;
/**
 * Infers the type from a firestore reference. If it is not a reference, it returns the type as is.
 *
 * @internal
 */
type _InferReferenceType<R> = R extends CollectionReference<infer T> | Query<infer T> | DocumentReference<infer T> ? T : R;
/**
 * Type used by default by the `firestoreDefaultConverter`.
 */
type VueFirestoreDocumentData<T = DocumentData> = null | (T & {
    /**
     * id of the document
     */
    readonly id: string;
});
type VueFirestoreQueryData<T = DocumentData> = Array<Exclude<VueFirestoreDocumentData<T>, null>>;
interface _RefFirestore<T> extends _RefWithState<T, FirestoreError> {
}
/**
 * Retrieves the Firestore instance.
 *
 * @param name - name of the application
 * @returns the Firestore instance
 */
declare function useFirestore(name?: string): firebase_firestore.Firestore;

/**
 * Default converter for Firestore data. Can be overridden by setting the
 */
declare const firestoreDefaultConverter: FirestoreDataConverter<VueFirestoreDocumentData>;

type VueFirestoreObject = Record<string, _FirestoreDataSource>;
type FirestoreOption = VueFirestoreObject | (() => VueFirestoreObject);
/**
 * Options for the Firebase Database Plugin that enables the Options API such as `$firestoreBind` and
 * `$firestoreUnbind`.
 */
interface FirestorePluginOptions extends FirestoreRefOptions {
    /**
     * @deprecated: was largely unused and not very useful. Please open an issue with use cases if you need this.
     */
    bindName?: string;
    /**
     * @deprecated: was largely unused and not very useful. Please open an issue with use cases if you need this.
     */
    unbindName?: string;
}
/**
 * Install this plugin to add `$firestoreBind` and `$firestoreUnbind` functions. Note this plugin is not necessary if
 * you exclusively use the Composition API (`useDocument()` and `useCollection()`).
 * @deprecated Use `VueFire` and `VueFireFirestoreOptionsAPI` with the `modules` option instead.b
 *
 * @param app
 * @param pluginOptions
 */
declare const firestorePlugin: (app: App, pluginOptions?: FirestorePluginOptions, firebaseApp?: FirebaseApp) => void;
/**
 * VueFire Firestore Module to be added to the `VueFire` Vue plugin options.
 *
 * @example
 *
 * ```ts
 * import { createApp } from 'vue'
 * import { VueFire, VueFireFirestoreOptionsAPI } from 'vuefire'
 *
 * const app = createApp(App)
 * app.use(VueFire, {
 *   modules: [VueFireFirestoreOptionsAPI()],
 * })
 * ```
 */
declare function VueFireFirestoreOptionsAPI(pluginOptions?: FirestorePluginOptions): (firebaseApp: FirebaseApp, app: App) => void;
declare module '@vue/runtime-core' {
    interface ComponentCustomProperties {
        /**
         * Binds a reference
         *
         * @param name
         * @param reference
         * @param options
         */
        $firestoreBind<T = DocumentData>(name: string, reference: Query<T> | CollectionReference<T>, options?: FirestoreRefOptions): Promise<T[]>;
        $firestoreBind<T = DocumentData>(name: string, reference: DocumentReference<T>, options?: FirestoreRefOptions): Promise<T>;
        /**
         * Unbinds a bound reference
         */
        $firestoreUnbind: (name: string, reset?: ResetOption) => void;
        /**
         * Bound firestore references
         */
        $firestoreRefs: Readonly<Record<string, DocumentReference<unknown> | CollectionReference<unknown>>>;
    }
    interface ComponentCustomOptions {
        /**
         * Calls `$firestoreBind` before mounting the component
         */
        firestore?: FirestoreOption;
    }
}

/**
 * Gets the firebase app instance.
 *
 * @param name - optional firebase app name
 * @returns the firebase app
 */
declare function useFirebaseApp(name?: string): FirebaseApp;

/**
 * Returns a shallowRef of the currently authenticated user in the firebase app. The ref is null if no user is
 * authenticated or when the user logs out. The ref is undefined when the user is not yet loaded.
 * @param name - name of the application
 */
declare function useCurrentUser(name?: string): Ref<_Nullable<User>>;
/**
 * Updates the current user profile and updates the current user state. This function internally calls `updateProfile()`
 * from 'firebase/auth' and then updates the current user state.
 *
 * @param user - the user to update
 * @param profile - the new profile information
 */
declare function updateCurrentUserProfile(profile: {
    displayName?: _Nullable<string>;
    photoURL?: _Nullable<string>;
}): Promise<void | undefined>;
/**
 * Returns a promise that resolves the current user once the user is loaded. Must be called after the firebase app is
 * initialized.
 */
declare function getCurrentUser(): Promise<_Nullable<User>>;

/**
 * VueFire Auth Module to be added to the `VueFire` Vue plugin options.
 *
 * @example
 *
 * ```ts
 * import { createApp } from 'vue'
 * import { VueFire, VueFireAuth } from 'vuefire'
 *
 * const app = createApp(App)
 * app.use(VueFire, {
 *   modules: [VueFireAuth()],
 * })
 * ```
 */
declare function VueFireAuth(_app?: never): (firebaseApp: FirebaseApp, app: App) => void;
/**
 * Retrieves the Firebase Auth instance.
 *
 * @param name - name of the application
 * @returns the Auth instance
 */
declare function useFirebaseAuth(name?: string): firebase_auth.Auth;

/**
 * Allows awaiting for all pending data sources. Useful to wait for SSR
 *
 * @param name - optional name of teh firebase app
 * @returns - a Promise that resolves with an array of all the resolved pending promises
 */
declare function usePendingPromises(app?: FirebaseApp): Promise<(readonly [string, unknown])[]>;

interface SSRStore {
    f: Record<string, unknown>;
    r: Record<string, unknown>;
    s: Record<string, string>;
    u: Record<string, unknown>;
}
/**
 * Allows getting the initial state set during SSR on the client.
 *
 * @param initialState - the initial state to set for the firebase app during SSR. Pass undefined to not set it
 * @param firebaseApp - the firebase app to get the initial state for
 * @returns the initial states for the current firebaseApp
 */
declare function useSSRInitialState(initialState?: SSRStore, firebaseApp?: FirebaseApp): SSRStore;

/**
 * The current app-check token as a `Ref`. Note this is undefined on the server.
 */
declare function useAppCheckToken(): Ref<string | undefined>;
interface VueFireAppCheckOptions extends AppCheckOptions {
    /**
     * Setups the debug token global. See https://firebase.google.com/docs/app-check/web/debug-provider. Note you should
     * set to false in production (or not set it at all).
     */
    debug?: boolean;
}
/**
 * VueFire AppCheck Module to be added to the `VueFire` Vue plugin options.
 *
 * @example
 *
 * ```ts
 * import { createApp } from 'vue'
 * import { VueFire, VueFireAppCheck } from 'vuefire'
 *
 * const app = createApp(App)
 * app.use(VueFire, {
 *   modules: [VueFireAppCheck()],
 * })
 * ```
 */
declare function VueFireAppCheck(options: VueFireAppCheckOptions): (firebaseApp: FirebaseApp, app: App) => void;

/**
 * Retrieves the Storage instance.
 *
 * @param name - name of the application
 * @returns the Database instance
 */
declare function useStorage(name?: string): firebase_storage.FirebaseStorage;
/**
 * Retrieves a reactive download URL of a `StorageReference`. Updates automatically if the `StorageReference` changes.
 *
 * @param storageRef - StorageReference
 */
declare function useStorageUrl(storageRef: _MaybeRef<_Nullable<StorageReference>>): {
    url: vue_demi.Ref<string | null | undefined>;
    refresh: () => {
        then: <TResult1 = string | null, TResult2 = never>(onfulfilled?: ((value: string | null) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
        catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<string | TResult | null>;
        finally: (onfinally?: (() => void) | null | undefined) => Promise<string | null>;
        readonly [Symbol.toStringTag]: string;
    };
    promise: vue_demi.Ref<{
        then: <TResult1 = string | null, TResult2 = never>(onfulfilled?: ((value: string | null) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
        catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<string | TResult | null>;
        finally: (onfinally?: (() => void) | null | undefined) => Promise<string | null>;
        readonly [Symbol.toStringTag]: string;
    }>;
};
/**
 * Returns a reactive version of the metadata of a `StorageReference`. Updates automatically if the `StorageReference`
 * changes.
 *
 * @param storageRef - StorageReference
 */
declare function useStorageMetadata(storageRef: _MaybeRef<_Nullable<StorageReference>>): {
    metadata: vue_demi.ShallowRef<FullMetadata | null | undefined>;
    update: (newMetadata: SettableMetadata) => Promise<FullMetadata | null>;
    refresh: () => Promise<FullMetadata | null>;
    promise: vue_demi.ShallowRef<Promise<FullMetadata | null>>;
};
/**
 * Reactive information (url, metadata) of a `StorageReference`. Allows updating and deleting the storage object.
 *
 * @param storageRef - StorageReference
 */
declare function useStorageObject(storageRef: _MaybeRef<_Nullable<StorageReference>>): {
    url: vue_demi.Ref<string | null | undefined>;
    metadata: vue_demi.ShallowRef<FullMetadata | null | undefined>;
    snapshot: vue_demi.ShallowRef<UploadTaskSnapshot | null | undefined>;
    uploadTask: vue_demi.ShallowRef<UploadTask | null | undefined>;
    uploadError: vue_demi.ShallowRef<StorageError | null | undefined>;
    uploadProgress: vue_demi.ComputedRef<number | null>;
    upload: (newData: Blob | Uint8Array | ArrayBuffer, newMetadata?: UploadMetadata) => Promise<unknown> | undefined;
    updateMetadata: (newMetadata: SettableMetadata) => Promise<FullMetadata | null>;
    refresh: () => Promise<[string | null, FullMetadata | null]>;
};

/**
 * Options for VueFire Vue plugin.
 */
interface VueFireOptions {
    /**
     * The firebase app used by VueFire and associated with the different modules.
     */
    firebaseApp: FirebaseApp;
    /**
     * Array of VueFire modules that should be added to the application. e.g. `[VueFireAuth, VueFireDatabase]`. Remember
     * to import them from `vuefire`.
     */
    modules?: Array<(firebaseApp: FirebaseApp, app: App) => void>;
}
/**
 * VueFire Vue plugin.
 */
declare function VueFire(app: App, { firebaseApp, modules }: VueFireOptions): void;

export { DatabasePluginOptions, DatabaseSnapshotSerializer, FirebaseOption, FirestoreOption, FirestorePluginOptions, UseCollectionOptions, UseDatabaseRefOptions, UseDocumentOptions, UseListOptions, UseObjectOptions, VueDatabaseDocumentData, VueDatabaseQueryData, VueFire, VueFireAppCheck, VueFireAuth, VueFireDatabaseOptionsAPI, VueFireFirestoreOptionsAPI, VueFireOptions, VueFirebaseObject, VueFirestoreDocumentData, VueFirestoreObject, VueFirestoreQueryData, _RefDatabase, _RefFirestore, databasePlugin, firestoreDefaultConverter, firestorePlugin, getCurrentUser, DEFAULT_OPTIONS$1 as globalDatabaseOptions, DEFAULT_OPTIONS as globalFirestoreOptions, databasePlugin as rtdbPlugin, updateCurrentUserProfile, useAppCheckToken, useCollection, useCurrentUser, useDatabase, useDocument, useFirebaseApp, useFirebaseAuth, useFirestore, useList, useObject, usePendingPromises, useSSRInitialState, useStorage, useStorageMetadata, useStorageObject, useStorageUrl };
